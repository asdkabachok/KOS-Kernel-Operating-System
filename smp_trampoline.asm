; smp_trampoline.asm — SMP Trampoline Code для x86_64
; Код для запуска дополнительных процессоров (AP - Application Processors)
; Этот код копируется в низкую память (ниже 1MB)

section .text
bits 16

; Глобальные метки
global ap_trampoline_start
global ap_trampoline_end
global ap_trampoline_size
global ap_stack_phys
global ap_pml4_phys
global ap_entry_phys

; ============================================================
; Начало trampoline кода
; AP CPU начинает выполнение отсюда после INIT/SIPI
; ============================================================
ap_trampoline_start:
    ; Очищаем сегментные регистры
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00          ; Используем стек в области загрузки
    
    ; Очищаем направление
    cld
    
    ; ============================================================
    ; Включаем A20 line (критично для доступа к памяти > 1MB)
    ; ============================================================
    in al, 0x92
    or al, 2
    out 0x92, al
    
    ; ============================================================
    ; Загружаем временную GDT для перехода в protected mode
    ; ============================================================
    lgdt [ap_gdt_descriptor]
    
    ; ============================================================
    ; Переходим в защищённый режим (32-bit)
    ; ============================================================
    mov eax, cr0
    or eax, 1               ; PE bit
    mov cr0, eax
    
    ; Far jump для перезагрузки сегментов
    jmp 0x08:.protected_mode

.bits 32
.protected_mode:
    ; Настраиваем сегменты
    mov ax, 0x10            ; Data segment selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    
    ; ============================================================
    ; Включаем PAE (Physical Address Extension)
    ; Необходимо для long mode
    ; ============================================================
    mov eax, cr4
    or eax, 1 << 5          ; PAE bit
    mov cr4, eax
    
    ; ============================================================
    ; Загружаем PML4 таблицу
    ; ============================================================
    mov eax, [ap_pml4_phys]
    mov cr3, eax
    
    ; ============================================================
    ; Включаем long mode через MSR
    ; ============================================================
    mov ecx, 0xC0000080      ; IA32_EFER MSR
    rdmsr
    or eax, 1 << 8           ; LME (Long Mode Enable)
    wrmsr
    
    ; ============================================================
    ; Включаем paging
    ; ============================================================
    mov eax, cr0
    or eax, 1 << 31          ; PG bit
    mov cr0, eax
    
    ; ============================================================
    ; Far jump в 64-bit режим
    ; ============================================================
    jmp 0x08:.long_mode

.bits 64
.long_mode:
    ; Настраиваем сегменты для 64-bit режима
    mov ax, 0x10            ; Kernel data selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    
    ; ============================================================
    ; Загружаем TSS для возможности использования syscalls
    ; ============================================================
    mov ax, 0x28            ; TSS selector
    ltr ax
    
    ; ============================================================
    ; Переключаемся на стек AP процессора
    ; ============================================================
    mov rsp, [ap_stack_phys]
    
    ; ============================================================
    ; Переходим на точку входа AP ядра
    ; ============================================================
    mov rax, [ap_entry_phys]
    jmp rax
    
    ; Если вернётся — останавливаем CPU
.halt:
    cli
    hlt
    jmp .halt

; ============================================================
; GDT для trampoline (временная)
; ============================================================
align 4
ap_gdt_start:
    dq 0                    ; Null descriptor
    ; Code segment (32-bit)
    dw 0xFFFF
    dw 0x0000
    db 0x00
    db 10011010b
    db 11001111b
    db 0x00
    ; Data segment
    dw 0xFFFF
    dw 0x0000
    db 0x00
    db 10010010b
    db 11001111b
    db 0x00
ap_gdt_end:

ap_gdt_descriptor:
    dw ap_gdt_end - ap_gdt_start - 1
    dd ap_gdt_start

; ============================================================
; Конец trampoline кода
; ============================================================
ap_trampoline_end:

; Размер trampoline кода
ap_trampoline_size:
    dd ap_trampoline_end - ap_trampoline_start

section .data

; Эти значения заполняются ядром при инициализации SMP

; Физический адрес PML4 (таблица страниц ядра)
ap_pml4_phys:
    dq 0

; Физический адрес стека для AP
ap_stack_phys:
    dq 0

; Физический адрес точки входа AP (ap_main)
ap_entry_phys:
    dq 0
